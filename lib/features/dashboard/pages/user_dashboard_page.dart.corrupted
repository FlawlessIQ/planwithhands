import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hands_app/services/daily_checklist_service.dart';
import 'package:hands_app/models/daily_checklist.dart';
import 'package:hands_app/data/models/shift_data.dart';
import 'package:hands_app/global_widgets/bottom_nav_bar.dart';
import 'package:hands_app/global_widgets/generic_app_bar_content.dart';
import 'package:hands_app/features/settings/pages/settings_page.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:image_picker/image_picker.dart';
import 'package:intl/intl.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'dart:io' show File;

class UserDashboardPage extends HookConsumerWidget {
  const UserDashboardPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = FirebaseAuth.instance.currentUser;
    final selectedLocationId = useState<String?>(null);
    final assignedShiftId = useState<String?>(null);
    final selectedShiftId = useState<String?>(null);
    final organizationId = useState<String?>(null);
    final userRole = useState<int>(0);
    final userLocationIds = useState<List<String>>([]);
    final jobTypes = useState<List<String>>([]);
    final dailyChecklistService = DailyChecklistService();
    final currentChecklists = useState<List<DailyChecklist>>([]);
    final isLoading = useState(false);
    final locations = useState<List<Map<String, dynamic>>>([]);
    final isUserDataLoading = useState<bool>(true);

    useEffect(() {
      _loadUserData(
        user,
        userRole,
        organizationId,
        userLocationIds,
        jobTypes,
        selectedLocationId,
        locations,
        isUserDataLoading,
      );
      // After user data is loaded, get today's assigned shift
      Future<void> getAssignedShift() async {
        if (user == null || organizationId.value == null || selectedLocationId.value == null) return;
        final today = DateTime.now();
        final weekStart = today.subtract(Duration(days: today.weekday - 1));
        // Find schedule for current week
        final scheduleQuery = await FirebaseFirestore.instance
            .collection('organizations')
            .doc(organizationId.value!)
            .collection('locations')
            .doc(selectedLocationId.value!)
            .collection('schedules')
            .where('startDate', isEqualTo: Timestamp.fromDate(weekStart))
            .limit(1)
            .get();
        if (scheduleQuery.docs.isEmpty) return;
        final schedId = scheduleQuery.docs.first.id;
        final entryQuery = await FirebaseFirestore.instance
            .collection('organizations')
            .doc(organizationId.value!)
            .collection('locations')
            .doc(selectedLocationId.value!)
            .collection('schedules')
            .doc(schedId)
            .collection('entries')
            .where('assignedUserIds', arrayContains: user.uid)
            .get();
        if (entryQuery.docs.isEmpty) return;
        final entryData = entryQuery.docs.first.data();
        assignedShiftId.value = entryData['shiftId'];
      }
      getAssignedShift();
      return null;
    }, [user, organizationId.value, selectedLocationId.value]);

    // Auto-generate daily checklists when organization is loaded
    useEffect(() {
      if (organizationId.value != null) {
        final service = DailyChecklistService();
        service.ensureDailyChecklistsExist(organizationId.value!).then((_) {
          debugPrint('Daily checklist generation check completed');
        }).catchError((e) {
          debugPrint('Error ensuring daily checklists exist: $e');
        });
      }
      return null;
    }, [organizationId.value]);

    useEffect(() {
      Future<void> loadDailyChecklists() async {
        if (assignedShiftId.value == null || 
            selectedLocationId.value == null || 
            organizationId.value == null) {
          currentChecklists.value = [];
          return;
        }

        isLoading.value = true;
        try {
          final today = DateTime.now();
          final dateString = '${today.year.toString().padLeft(4, '0')}-${today.month.toString().padLeft(2, '0')}-${today.day.toString().padLeft(2, '0')}';
          // Get the shift data to access its checklist templates
          final shiftDoc = await FirebaseFirestore.instance
              .collection('organizations')
              .doc(organizationId.value!)
              .collection('shifts')
              .doc(assignedShiftId.value!)
              .get();
          if (!shiftDoc.exists) {
            currentChecklists.value = [];
            return;
          }
          final shiftData = ShiftData.fromJson(shiftDoc.data()!);
          if (shiftData.checklistTemplateIds.isEmpty) {
            currentChecklists.value = [];
            return;
          }
          // Generate/get daily checklists for this shift
          final checklists = await dailyChecklistService.generateDailyChecklists(
            organizationId: organizationId.value!,
            locationId: selectedLocationId.value!,
            shiftId: assignedShiftId.value!,
            shiftData: shiftData,
            date: dateString,
          );
          currentChecklists.value = checklists;
        } catch (e) {
          debugPrint('Error loading daily checklists: $e');
          currentChecklists.value = [];
        } finally {
          isLoading.value = false;
        }
      }
      loadDailyChecklists();
      return null;
    }, [assignedShiftId.value, selectedLocationId.value, organizationId.value]);

    if (user == null) {
      return Scaffold(
        body: const Center(child: Text('Not signed in')),
        bottomNavigationBar: BottomNavBar(currentIndex: 0),
      );
    }

    if (isUserDataLoading.value) {
      return Scaffold(
        body: const Center(child: CircularProgressIndicator()),
        bottomNavigationBar: BottomNavBar(currentIndex: 0),
      );
    }

    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).primaryColor,
        title: const GenericAppBarContent(appBarTitle: 'Dashboard'),
        automaticallyImplyLeading: false,
        iconTheme: const IconThemeData(color: Colors.white),
      ),
      body: MediaQuery(
        data: MediaQuery.of(context).copyWith(
          textScaler: MediaQuery.of(context).textScaler.clamp(
            minScaleFactor: 1.0,
            maxScaleFactor: 1.2,
          ),
        ),
        child: SafeArea(
          child: SingleChildScrollView(
            physics: const AlwaysScrollableScrollPhysics(),
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // User role indicator
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                  decoration: BoxDecoration(
                    color: Theme.of(context).primaryColor.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(color: Theme.of(context).primaryColor),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Icon(Icons.person, size: 16),
                      const SizedBox(width: 4),
                      Text(
                        userRole.value == 2 
                            ? 'Admin'
                            : userRole.value == 1 
                                ? 'Manager' 
                                : 'Staff',
                        style: TextStyle(
                          color: Theme.of(context).primaryColor, 
                          fontSize: 14,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
                // Auto-detect assigned shift or show cover shift option
                if (assignedShiftId.value != null) ...[
                  Row(
                    children: [
                      const Icon(Icons.work, size: 24),
                      const SizedBox(width: 8),
                      const Text('Your Assigned Shift', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text('Today\'s Shift', style: Theme.of(context).textTheme.titleMedium),
                          const SizedBox(height: 8),
                          Text('Shift ID: ${assignedShiftId.value}'),
                          // Add more shift details here
                        ],
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                ] else ...[
                  // Show cover shift option
                  Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Column(
                        children: [
                          const Icon(Icons.volunteer_activism, size: 48, color: Colors.blue),
                          const SizedBox(height: 8),
                          Text('No Shift Assigned Today', style: Theme.of(context).textTheme.titleMedium),
                          const SizedBox(height: 8),
                          const Text('Would you like to cover another shift?'),
                          const SizedBox(height: 16),
                          ElevatedButton(
                            onPressed: () {
                              // Navigate to available shifts
                            },
                            child: const Text('Cover Another Shift'),
                          ),
                        ],
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                // Daily Checklists Section
                if (selectedShiftId.value != null || assignedShiftId.value != null) ...[
                  Row(
                    children: [
                      const Icon(Icons.checklist, size: 24),
                      const SizedBox(width: 8),
                      const Text('Daily Checklists', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                    ],
                  ),
                  const SizedBox(height: 16),

                  if (isLoading.value)
                    const Center(child: CircularProgressIndicator())
                  else if (currentChecklists.value.isNotEmpty)
                    ...currentChecklists.value.map((checklist) => 
                      _buildChecklistCard(checklist, context, selectedLocationId, organizationId))
                  else
                    const Card(
                      child: Padding(
                        padding: EdgeInsets.all(16),
                        child: Text('No checklists available for today'),
                      ),
                    ),
                  const SizedBox(height: 16),
                ],

                // Additional content can be added here
                const SizedBox(height: 100), // Space for bottom nav
              ],
            ),
          ),
        ),
      ),
      bottomNavigationBar: const BottomNavBar(currentIndex: 0),
    );
                    itemBuilder: (context, index) {
                      final checklist = currentChecklists.value[index];
                      return _buildChecklistCard(
                        checklist,
                        dailyChecklistService,
                        user.uid,
                        organizationId.value!,
                        selectedLocationId.value,
                        () {
                          // Refresh callback
                          final updatedList = List<DailyChecklist>.from(currentChecklists.value);
                          currentChecklists.value = updatedList;
                        },
                      );
                    },
                  ),
                )
              else
                const Center(child: Text('No checklist templates assigned to this shift')),
            ] else ...[
              const Expanded(
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.work_outline, size: 64, color: Colors.grey),
                      SizedBox(height: 16),
                      Text(
                        'Select a shift to view your daily checklists',
                        style: TextStyle(fontSize: 16, color: Colors.grey),
                        textAlign: TextAlign.center,
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
      bottomNavigationBar: BottomNavBar(currentIndex: 0),
    );
  }

  Widget _buildChecklistCard(
    DailyChecklist checklist,
    DailyChecklistService service,
    String userId,
    String organizationId,
    String? locationId,
    VoidCallback onRefresh,
  ) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Checklist header
            Row(
              children: [
                Expanded(
                  child: Text(
                    checklist.templateName ?? 'Checklist',
                    style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                ),
                // Real-time completion status using StreamBuilder
                StreamBuilder<DocumentSnapshot>(
                  stream: FirebaseFirestore.instance
                      .collection('organizations')
                      .doc(organizationId)
                      .collection('daily_checklists')
                      .doc(checklist.id)
                      .snapshots(),
                  builder: (context, snapshot) {
                    if (!snapshot.hasData) return const SizedBox.shrink();
                    
                    final data = snapshot.data!.data() as Map<String, dynamic>?;
                    final isCompleted = data?['isCompleted'] ?? false;
                    
                    if (isCompleted) {
                      return Container(
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        decoration: BoxDecoration(
                          color: Colors.green,
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: const Text(
                          'Completed',
                          style: TextStyle(color: Colors.white, fontSize: 12),
                        ),
                      );
                    }
                    return const SizedBox.shrink();
                  },
                ),
              ],
            ),
            const SizedBox(height: 8),

            // Real-time progress indicator using StreamBuilder
            StreamBuilder<DocumentSnapshot>(
              stream: FirebaseFirestore.instance
                  .collection('organizations')
                  .doc(organizationId)
                  .collection('daily_checklists')
                  .doc(checklist.id)
                  .snapshots(),
              builder: (context, snapshot) {
                if (!snapshot.hasData) {
                  return Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.grey.shade100,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const LinearProgressIndicator(),
                  );
                }
                
                final checklistData = snapshot.data!.data() as Map<String, dynamic>?;
                final tasksArray = List<Map<String, dynamic>>.from(checklistData?['tasks'] ?? []);
                final completedTasks = tasksArray.where((task) => task['completed'] ?? false).length;
                final totalTasks = tasksArray.length;
                final percentage = totalTasks > 0 ? (completedTasks / totalTasks * 100).round() : 0;
                
                return Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.grey.shade100,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Column(
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            '$completedTasks/$totalTasks tasks completed',
                            style: const TextStyle(fontWeight: FontWeight.w500),
                          ),
                          Text(
                            '$percentage%',
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      LinearProgressIndicator(
                        value: totalTasks > 0 ? completedTasks / totalTasks : 0,
                        backgroundColor: Colors.grey.shade300,
                        valueColor: AlwaysStoppedAnimation<Color>(
                          completedTasks == totalTasks && totalTasks > 0 ? Colors.green : Colors.blue,
                        ),
                      ),
                    ],
                  ),
                );
              },
            ),
            const SizedBox(height: 12),

            // Real-time tasks list using StreamBuilder on the checklist document
            StreamBuilder<DocumentSnapshot>(
              stream: FirebaseFirestore.instance
                  .collection('organizations')
                  .doc(organizationId)
                  .collection('daily_checklists')
                  .doc(checklist.id)
                  .snapshots(),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }
                
                if (!snapshot.hasData) {
                  return const Text('No checklist data available');
                }

                final checklistData = snapshot.data!.data() as Map<String, dynamic>?;
                if (checklistData == null) {
                  return const Text('Checklist data is null');
                }

                final tasksArray = List<Map<String, dynamic>>.from(checklistData['tasks'] ?? []);
                
                if (tasksArray.isEmpty) {
                  return const Text('No tasks available');
                }
                
                return Column(
                  children: tasksArray.map((taskData) {
                    return _TaskCard(
                      task: DailyChecklistTask.fromMap(taskData),
                      checklistId: checklist.id,
                      userId: userId,
                      organizationId: organizationId,
                      locationId: locationId,
                      service: service,
                      onTaskUpdated: onRefresh,
                    );
                  }).toList(),
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _loadUserData(
    User? user,
    ValueNotifier<int> userRole,
    ValueNotifier<String?> organizationId,
    ValueNotifier<List<String>> userLocationIds,
    ValueNotifier<List<String>> jobTypes,
    ValueNotifier<String?> selectedLocationId,
    ValueNotifier<List<Map<String, dynamic>>> locations,
    ValueNotifier<bool> isUserDataLoading,
  ) async {
    if (user == null) return;

    try {
      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .get();

      if (userDoc.exists) {
        final userData = userDoc.data()!;
        // Fix: reading from correct field name (userRole instead of role)
        final roleValue = userData['userRole'] ?? 0;
        userRole.value = roleValue;
        organizationId.value = userData['organizationId'];
        userLocationIds.value = List<String>.from(userData['locationIds'] ?? []);
        jobTypes.value = List<String>.from(userData['jobType'] ?? []);

        // Debug print user data
        debugPrint('User data loaded: role=$roleValue, orgId=${organizationId.value}');
        debugPrint('User job types: ${jobTypes.value.join(', ')}');
        debugPrint('User location IDs: ${userLocationIds.value.join(', ')}');

        // Load locations
        if (organizationId.value != null) {
          await _loadLocations(organizationId.value!, userLocationIds.value, locations);
        }

        // Load saved location preference
        final prefs = await SharedPreferences.getInstance();
        final savedLocationId = prefs.getString('selectedLocationId');
        if (savedLocationId != null && userLocationIds.value.contains(savedLocationId)) {
          selectedLocationId.value = savedLocationId;
        }
      }
    } catch (e) {
      debugPrint('Error loading user data: $e');
    } finally {
      isUserDataLoading.value = false;
    }
  }

  Future<void> _loadLocations(
    String orgId,
    List<String> userLocationIds,
    ValueNotifier<List<Map<String, dynamic>>> locations,
  ) async {
    try {
      debugPrint('Loading locations for org: $orgId, user has ${userLocationIds.length} locations');

      // Get current user role from the user data loading
      final user = FirebaseAuth.instance.currentUser;
      int currentUserRole = 0;
      if (user != null) {
        try {
          final userDoc = await FirebaseFirestore.instance
              .collection('users')
              .doc(user.uid)
              .get();
          if (userDoc.exists) {
            currentUserRole = userDoc.data()?['userRole'] ?? 0;
          }
        } catch (e) {
          debugPrint('Error getting user role: $e');
        }
      }

      final QuerySnapshot locationsQuery;
      
      if (currentUserRole > 0 || userLocationIds.isEmpty) {
        // Admins & managers see all locations
        locationsQuery = await FirebaseFirestore.instance
            .collection('organizations')
            .doc(orgId)
            .collection('locations')
            .get();
        debugPrint('Loading all locations (admin/manager or no user locations found)');
      } else {
        // Regular users see only their assigned locations
        if (userLocationIds.length <= 10) {
          locationsQuery = await FirebaseFirestore.instance
              .collection('organizations')
              .doc(orgId)
              .collection('locations')
              .where(FieldPath.documentId, whereIn: userLocationIds)
              .get();
          debugPrint('Loaded locations using whereIn for regular user');
        } else {
          // If more than 10 locations, get all and filter in memory
          locationsQuery = await FirebaseFirestore.instance
              .collection('organizations')
              .doc(orgId)
              .collection('locations')
              .get();
          debugPrint('Loaded all locations (user has >10 locations)');
        }
      }
      
      // Process the results
      List<Map<String, dynamic>> locationsList;
      if (currentUserRole > 0 || userLocationIds.isEmpty || userLocationIds.length > 10) {
        // Direct mapping for admins/managers or when we loaded all locations
        locationsList = locationsQuery.docs
            .map((doc) => {
                  'id': doc.id,
                  'locationName': (doc.data() as Map<String, dynamic>)['locationName'] ?? doc.id,
                })
            .where((loc) => currentUserRole > 0 || userLocationIds.isEmpty || userLocationIds.contains(loc['id']))
            .toList();
      } else {
        // Direct mapping if we used whereIn for regular users
        locationsList = locationsQuery.docs
            .map((doc) {
              final data = doc.data();
              final mapData = data as Map<String, dynamic>?;
              return {
                'id': doc.id,
                'locationName': (mapData != null && mapData['locationName'] != null) ? mapData['locationName'] : doc.id,
              };
            })
            .toList();
      }
      
      debugPrint('Final location list has ${locationsList.length} locations for role $currentUserRole');
      locations.value = locationsList;
    } catch (e) {
      debugPrint('Error loading locations: $e');
      locations.value = [];
    }
  }
}

class _TaskCard extends StatefulWidget {
  final DailyChecklistTask task;
  final String checklistId;
  final String userId;
  final String organizationId;
  final DailyChecklistService service;
  final VoidCallback onTaskUpdated;
  final String? locationId;

  const _TaskCard({
    required this.task,
    required this.checklistId,
    required this.userId,
    required this.organizationId,
    required this.locationId,
    required this.service,
    required this.onTaskUpdated,
  });

  @override
  State<_TaskCard> createState() => _TaskCardState();
}

class _TaskCardState extends State<_TaskCard> {
  bool _isUpdating = false;
  bool _isAddingReason = false;

  Future<void> _addReasonForNotCompleting() async {
    if (_isAddingReason) return;

    final reasonController = TextEditingController();

    await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Reason for Not Completing Task'),
        content: TextField(
          controller: reasonController,
          decoration: const InputDecoration(
            hintText: 'Enter reason here',
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              final reason = reasonController.text.trim();
              if (reason.isNotEmpty) {
                setState(() => _isAddingReason = true);
                try {
                  await widget.service.updateTaskReason(
                    organizationId: widget.organizationId,
                    checklistId: widget.checklistId,
                    taskId: widget.task.taskId,
                    reason: reason,
                    locationId: widget.locationId!,
                  );
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Reason added successfully!')),
                  );
                } catch (e) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Error adding reason: $e')),
                  );
                } finally {
                  setState(() => _isAddingReason = false);
                }
              }
              Navigator.of(context).pop();
            },
            child: const Text('Submit'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey.shade300),
        borderRadius: BorderRadius.circular(8),
        color: widget.task.isCompleted ? Colors.green.shade50 : Colors.white,
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Checkbox(
                value: widget.task.isCompleted,
                onChanged: _isUpdating ? null : (bool? value) => _toggleTask(value ?? false),
              ),
              Expanded(
                child: Text(
                  widget.task.description,
                  style: TextStyle(
                    fontSize: 16,
                    decoration: widget.task.isCompleted ? TextDecoration.lineThrough : null,
                    color: widget.task.isCompleted ? Colors.grey : Colors.black,
                  ),
                ),
              ),
              if (_isUpdating)
                const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                ),
            ],
          ),
          if (widget.task.notes != null && widget.task.notes!.isNotEmpty) ...[
            const SizedBox(height: 4),
            Padding(
              padding: const EdgeInsets.only(left: 48),
              child: Text(
                widget.task.notes!,
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.grey.shade600,
                ),
              ),
            ),
          ],
          if (widget.task.proofImageUrl != null) ...[
            const SizedBox(height: 8),
            Padding(
              padding: const EdgeInsets.only(left: 48),
              child: Row(
                children: [
                  const Icon(Icons.check_circle, color: Colors.green, size: 16),
                  const SizedBox(width: 4),
                  const Text('Photo uploaded', style: TextStyle(color: Colors.green)),
                  const SizedBox(width: 8),
                  TextButton(
                    onPressed: () => _showPhotoDialog(widget.task.proofImageUrl!),
                    child: const Text('View'),
                  ),
                ],
              ),
            ),
          ],
          if (widget.task.completedAt != null) ...[
            const SizedBox(height: 4),
            Padding(
              padding: const EdgeInsets.only(left: 48),
              child: Text(
                'Completed at ${_formatTime(widget.task.completedAt!)}',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey.shade600,
                ),
              ),
            ),
          ],
          // Add reason icon button
          Row(
            children: [
              const SizedBox(width: 40), // Space for the checkbox
              IconButton(
                icon: const Icon(Icons.info_outline, color: Colors.orange),
                tooltip: 'Add Reason for Not Completing',
                onPressed: _addReasonForNotCompleting,
              ),
            ],
          ),
        ],
      ),
    );
  }

  Future<void> _toggleTask(bool completed) async {
    if (_isUpdating) return;

    setState(() => _isUpdating = true);

    try {
      await widget.service.updateTaskCompletion(
        organizationId: widget.organizationId,
        checklistId: widget.checklistId,
        taskId: widget.task.taskId,
        completed: completed,
        locationId: widget.locationId!,
      );
      widget.onTaskUpdated();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error updating task: $e')),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isUpdating = false);
      }
    }
  }


  void _showPhotoDialog(String photoUrl) {
    showDialog(
      context: context,
      builder: (context) => Dialog(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            AppBar(
              title: const Text('Task Photo'),
              automaticallyImplyLeading: false,
              actions: [
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ],
            ),
            Padding(
              padding: const EdgeInsets.all(16),
              child: Image.network(
                photoUrl,
                fit: BoxFit.contain,
                loadingBuilder: (context, child, loadingProgress) {
                  if (loadingProgress == null) return child;
                  return const Center(child: CircularProgressIndicator());
                },
                errorBuilder: (context, error, stackTrace) {
                  return const Center(
                    child: Text('Error loading image'),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _RealtimeTaskCard extends StatefulWidget {
  final Map<String, dynamic> taskData;
  final String checklistId;
  final String organizationId;
  final String? locationId;

  const _RealtimeTaskCard({
    required this.taskData,
    required this.checklistId,
    required this.organizationId,
    required this.locationId,
  });

  @override
  State<_RealtimeTaskCard> createState() => _RealtimeTaskCardState();
}

class _RealtimeTaskCardState extends State<_RealtimeTaskCard> {
  final ImagePicker _picker = ImagePicker();
  bool _isUploading = false;
  bool _isAddingReason = false;

  Future<void> _addReasonForNotCompleting() async {
    if (_isAddingReason) return;
    final reasonController = TextEditingController();
    await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Reason for Not Completing Task'),
        content: TextField(
          controller: reasonController,
          decoration: const InputDecoration(
            hintText: 'Enter reason here',
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              final reason = reasonController.text.trim();
              if (reason.isNotEmpty) {
                setState(() => _isAddingReason = true);
                try {
                  final service = DailyChecklistService();
                  final taskId = widget.taskData['id'] ?? widget.taskData['taskId'] ?? '';
                  await service.updateTaskReason(
                    organizationId: widget.organizationId,
                    checklistId: widget.checklistId,
                    taskId: taskId,
                    reason: reason,
                    locationId: widget.locationId!,
                  );
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Reason added successfully!')),
                  );
                } catch (e) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Error adding reason: $e')),
                  );
                } finally {
                  setState(() => _isAddingReason = false);
                }
              }
              Navigator.of(context).pop();
            },
            child: const Text('Submit'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final isCompleted = widget.taskData['completed'] ?? 
                       widget.taskData['isCompleted'] ?? 
                       false;
    
    // Try multiple field names for task title/description
    final title = widget.taskData['description'] ?? 
                  widget.taskData['title'] ?? 
                  widget.taskData['name'] ?? 
                  widget.taskData['taskName'] ?? 
                  widget.taskData['taskTitle'] ?? 
                  'No Title';
    
    debugPrint('Task data for display: ${widget.taskData}');
    debugPrint('Resolved task title: "$title"');
    
    final notes = widget.taskData['notes'] ?? '';
    final photoUrl = widget.taskData['photoUrl'] ?? widget.taskData['proofImageUrl'];
    final photoRequired = widget.taskData['photoRequired'] ?? false;
    
    // Handle completion timestamp
    final completedAt = widget.taskData['completedAt'];
    DateTime? completedDateTime;
    if (completedAt != null) {
      if (completedAt is Timestamp) {
        completedDateTime = completedAt.toDate();
      } else if (completedAt is String) {
        try {
          completedDateTime = DateTime.parse(completedAt);
        } catch (e) {
          debugPrint('Error parsing completedAt: $e');
        }
      }
    }

    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: isCompleted ? Colors.green.shade50 : Colors.white,
        border: Border.all(
          color: isCompleted ? Colors.green.shade200 : Colors.grey.shade300,
        ),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              // Task completion checkbox
              Checkbox(
                value: isCompleted,
                onChanged: (newValue) async {
                  // If photo is required but not uploaded, show popup dialog
                  if (newValue == true && photoRequired && photoUrl == null) {
                    _showPhotoRequiredDialog();
                    return;
                  }

                  final user = FirebaseAuth.instance.currentUser;
                  if (user == null) return;

                  // Get user information for certification
                  String? userName;
                  String? userEmail = user.email;
                  
                  try {
                    final userDoc = await FirebaseFirestore.instance
                        .collection('users')
                        .doc(user.uid)
                        .get();
                    
                    if (userDoc.exists) {
                      final userData = userDoc.data()!;
                      userName = userData['firstName'] ?? userData['lastName'] ?? userData['name'] ?? userData['displayName'] ?? user.displayName;
                    }
                  } catch (e) {
                    debugPrint('Error getting user data for certification: $e');
                  }
                  
                  // Use the DailyChecklistService to update the task properly with user certification
                  try {
                    final service = DailyChecklistService();
                    final taskId = widget.taskData['id'] ?? widget.taskData['taskId'] ?? '';
                    
                    await service.updateTaskCompletion(
                      organizationId: widget.organizationId,
                      checklistId: widget.checklistId,
                      taskId: taskId,
                      completed: newValue ?? false,
                      completedByUserId: user.uid,
                      completedByUserName: userName,
                      completedByUserEmail: userEmail,
                      locationId: widget.locationId!,
                    );
                  } catch (e) {
                    if (mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Error updating task: $e')),
                      );
                    }
                  }
                },
              ),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            title,
                            style: TextStyle(
                              fontWeight: FontWeight.w500,
                              fontSize: 16,
                              decoration: isCompleted ? TextDecoration.lineThrough : null,
                              color: isCompleted ? Colors.grey : null,
                            ),
                          ),
                        ),
                        // Photo requirement indicator
                        if (photoRequired)
                          Container(
                            margin: const EdgeInsets.only(left: 8),
                            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                            decoration: BoxDecoration(
                              color: photoUrl != null ? Colors.green.shade100 : Colors.orange.shade100,
                              borderRadius: BorderRadius.circular(4),
                              border: Border.all(
                                color: photoUrl != null ? Colors.green.shade300 : Colors.orange.shade300,
                              ),
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Icon(
                                  photoUrl != null ? Icons.check_circle : Icons.camera_alt,
                                  size: 12,
                                  color: photoUrl != null ? Colors.green.shade700 : Colors.orange.shade700,
                                ),
                                const SizedBox(width: 2),
                                Text(
                                  photoUrl != null ? 'Photo ✓' : 'Photo Required',
                                  style: TextStyle(
                                    fontSize: 10,
                                    color: photoUrl != null ? Colors.green.shade700 : Colors.orange.shade700,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              ],
                            ),
                          ),
                      ],
                    ),
                    if (completedDateTime != null) ...[
                      const SizedBox(height: 4),
                      Text(
                        'Completed at ${DateFormat('MMM d, y h:mm a').format(completedDateTime)}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey.shade600,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              // Photo upload/view button for ALL tasks
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (_isUploading)
                    const SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  else if (photoUrl != null)
                    IconButton(
                      onPressed: () => _showPhotoDialog(photoUrl),
                      icon: const Icon(Icons.visibility, color: Colors.green),
                      tooltip: 'View Photo',
                    )
                  else
                    IconButton(
                      onPressed: _uploadPhoto,
                      icon: const Icon(Icons.camera_alt, color: Colors.blue),
                      tooltip: 'Upload Photo',
                    ),
                  // Add Reason icon button
                  IconButton(
                    icon: const Icon(Icons.info_outline, color: Colors.orange),
                    tooltip: 'Add Reason for Not Completing',
                    onPressed: _addReasonForNotCompleting,
                  ),
                ],
              ),
            ],
          ),
          if (notes.isNotEmpty) ...[
            const SizedBox(height: 4),
            Padding(
              padding: const EdgeInsets.only(left: 48),
              child: Text(
                notes,
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.grey.shade600,
                ),
              ),
            ),
          ],
          // Display photo indicator if photo exists
          if (photoUrl != null && !photoRequired) ...[
            const SizedBox(height: 8),
            Padding(
              padding: const EdgeInsets.only(left: 48),
              child: Row(
                children: [
                  const Icon(Icons.check_circle, color: Colors.green, size: 16),
                  const SizedBox(width: 4),
                  const Text('Photo uploaded', style: TextStyle(color: Colors.green, fontSize: 12)),
                ],
              ),
            ),
          ],
        ],
      ),
    );
  }

  Future<void> _uploadPhoto() async {
    if (_isUploading) return;

    try {
      final source = await _showImageSourceDialog();
      if (source == null) return;

      final XFile? image = await _picker.pickImage(
        source: source,
        imageQuality: 80,
        maxWidth: 1024,
        maxHeight: 1024,
      );

      if (image == null) return;

      setState(() => _isUploading = true);

      final user = FirebaseAuth.instance.currentUser;
      if (user == null) throw Exception('User not authenticated');

      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final taskId = widget.taskData['id']?.toString() ?? 'unknown';
      final storagePath = 'task_photos/${widget.organizationId}/${widget.checklistId}/${taskId}_$timestamp.jpg';
      final storageRef = FirebaseStorage.instance.ref().child(storagePath);

      UploadTask uploadTask;
      if (kIsWeb) {
        final bytes = await image.readAsBytes();
        uploadTask = storageRef.putData(
          bytes,
          SettableMetadata(contentType: 'image/jpeg'),
        );
      } else {
        final file = File(image.path);
        if (!await file.exists()) {
          throw Exception('Image file not found at path: ${image.path}');
        }
        uploadTask = storageRef.putFile(file);
      }

      final snapshot = await uploadTask.whenComplete(() => null);
      final downloadUrl = await snapshot.ref.getDownloadURL();

      final service = DailyChecklistService();
      await service.updateTaskPhoto(
        organizationId: widget.organizationId,
        checklistId: widget.checklistId,
        taskId: widget.taskData['id'],
        photoUrl: downloadUrl,
        locationId: widget.locationId!,
      );

      await service.updateTaskCompletion(
        organizationId: widget.organizationId,
        checklistId: widget.checklistId,
        taskId: widget.taskData['id'],
        completed: true,
        locationId: widget.locationId!,
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Photo uploaded and task completed successfully!'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error uploading photo: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isUploading = false);
      }
    }
  }

  Future<ImageSource?> _showImageSourceDialog() async {
    return await showDialog<ImageSource>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Select Image Source'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.camera_alt),
              title: const Text('Take a photo'),
              onTap: () => Navigator.of(context).pop(ImageSource.camera),
            ),
            ListTile(
              leading: const Icon(Icons.photo_library),
              title: const Text('Choose from gallery'),
              onTap: () => Navigator.of(context).pop(ImageSource.gallery),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
        ],
      ),
    );
  }

  void _showPhotoDialog(String photoUrl) {
    showDialog(
      context: context,
      builder: (context) => Dialog(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            AppBar(
              title: const Text('Task Photo'),
              automaticallyImplyLeading: false,
              actions: [
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ],
            ),
            Padding(
              padding: const EdgeInsets.all(16),
              child: Image.network(
                photoUrl,
                fit: BoxFit.contain,
                loadingBuilder: (context, child, loadingProgress) {
                  if (loadingProgress == null) return child;
                  return const Center(child: CircularProgressIndicator());
                },
                errorBuilder: (context, error, stackTrace) {
                  return const Center(
                    child: Text('Error loading image'),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _showPhotoRequiredDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Photo Required'),
        content: const Text('This task requires a photo to be completed. Please upload a photo to proceed.'),
        actions: [
          TextButton(
            child: const Text('Upload Photo'),
            onPressed: () async {
              Navigator.of(context).pop();
              await _uploadPhoto();
            },
          ),
          TextButton(
            child: const Text('Cancel'),
            onPressed: () => Navigator.of(context).pop(),
          ),
        ],
      ),
    );
  }
}

String _formatTime(DateTime dateTime) {
    return DateFormat('h:mm a').format(dateTime);
  }

// Optimized the "View Details" button for mobile by ensuring it fits within the card layout and adjusts dynamically based on screen size.
Widget _buildHistoricShiftPerformanceCard(String shiftName, String performanceDetails) {
  return Card(
    margin: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
    child: Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            shiftName,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            performanceDetails,
            style: const TextStyle(
              fontSize: 14,
              color: Colors.grey,
            ),
          ),
          const SizedBox(height: 16),
          Align(
            alignment: Alignment.centerRight,
            child: ElevatedButton(
              onPressed: () {
                // Handle "View Details" action
              },
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                minimumSize: const Size(80, 36), // Ensures button fits well on mobile
              ),
              child: const Text(
                'View Details',
                style: TextStyle(fontSize: 14),
              ),
            ),
          ),
        ],
      ),
    ),
  );
}

